---
smip: 0002
title: SVM-v0.2-Storage-Layer
status: WIP
type: Standards(Core)
author: Yaron Wittenstein <yaron.wittenstein@gmail.com>
created: 2020-04-30
---

## Motivation

SVM v0.2 should come with the minimum set of features required for implementing the [_Smart Wallet App_][smart-wallet].
The implementation should be compatible with future SVM versions. It means that we need to carefully think about the next steps.
We must strive not to implement things which will have to be maintained only as backward-compatibility for the [_Smart Wallet App_][smart-wallet].


## Specification 

Each deployed `App Template` will contain along its code (i.e wasm program) a section containing metadata.
The metadata section will include the data-layout specification for storage of the program.

Each fixed-size program variable will have an index (a.k.a `var_id`), `offset` and `len` (byte-length). 
The `var_id` and `offset` are zero-indexed and `len` is within range `[1 - 8]`

Here is an example for a data-layout.
```
+----------+---------+-------+
|  var_id  |  offset |  len  |
+--------------------+-------+
|    0     |    0    |   2   |
|    1     |    2    |   4   |
|    2     |    6    |   8   |
|    3     |   14    |   2   |
+----------------------------+
```

In case a program has no explicit data-layout, it'll fallback to a default data-layout where each variable
if of `8` bytes. So the variable `#i` will map to `offset=8 * i`.
<br>

SVM's Storage Layer will expose two functions named `get64` and `set64` for reading and writing variables respectively.
<br>

In order to read variable with `var_id=2` a wasm program will call `get64(2)` and receive a `value` of 64-bit integer.
The Storage Layer will always return 64-bit even for variables having `len < 8`.
It'll be able to do since it'll have access to the data-layout of the program.
Similary, a wasm program asking to write the value `100` to `var_id=2` will call `set64(2, 100)`.

<br>

Each SVM wasm program could (optional) use these 2 imports function:
```
func get64(var_id: i32) -> value: i64
func set64(var_id: i32, value: i64)
```

Each call to `get64` and `set64` will cost the same amount of gas respectively.
SVM will have an internal Gas metering table for each import function.

<br>

The reason for being optional is because each program may use a different set of imports.
For the scope of the _SVM Wallet App_ - the program will use both functions.


## Rationale

The design of SVM should be both minimal, usable for the future and gas-estimation friendly.
Regarding the minimal - having only the above 2 imports should be enough for the _Smart Wallet App_.
Also, future programs will benefit from its simplicity. Regrading gas-estimation friendly.
We could add more imports like: `get8`, `get16`, `get24` and similar in order to differentiate between the size of the variable.

<br>

However, since each variable byte-length is within range `[1 - 8]` we've decided to have the same gas code for each read and write call.
It still keeps to door open for adding future calls specifying the exact variable length but it's unlikely it'll be required.
A more important gas factor should taken into account the total size of the variables. This should incentivize programs to ask for the minimum
required storage.

<br>

Another gas-factor that we need to count on is the way data is persisted.
Given a data-layout - if we can use manage it in different ways it could affect the total gas cost executing an app transaction.


## Test Cases
TBD

## Implementations
TBD


## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).



[smart-wallet]: https://github.com/spacemeshos/product/blob/master/svm-wallet.md
